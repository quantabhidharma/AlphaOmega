using LinearAlgebra
using Statistics
using Random
using Dates
using Base.Threads # Unlock the M4 Max Cores

# --- HARDWARE CONFIG ---
const L = 8           # 8x8x8x8 (Use the 128GB headroom)
const N_COLORS = 3    # SU(3)
const β_START = 5.0   # Start closer to the transition
const β_END = 8.0     # Deep weak coupling
const STEPS = 50      # Beta steps
const THERMAL_SWEEPS = 200 # Heavy burn-in per step to fix the "jitter"

# --- THE TWIST (Eguchi-Kawai) ---
const Z3 = exp(2π * im / 3)
const TWIST_PHASE = ComplexF64[Z3 0 0; 0 1 0; 0 0 1/Z3]

# --- PHYSICS ENGINE ---

function random_SU3(ϵ)
    R = randn(ComplexF64, 3, 3)
    H = (R + R') / 2
    H = H - tr(H)/3 * I
    return exp(im * ϵ * H)
end

function get_staple_twisted(U, t, x, y, z, μ)
    staple = zeros(ComplexF64, 3, 3)
    coords = [t, x, y, z]
    
    for ν in 1:4
        if μ == ν; continue; end
        
        # Forward Staple Logic
        c_up_ν = copy(coords); c_up_ν[ν] += 1
        c_up_μ = copy(coords); c_up_μ[μ] += 1
        
        twist_factor = I
        if c_up_ν[ν] > L; c_up_ν[ν] = 1; twist_factor *= TWIST_PHASE; end
        if c_up_μ[μ] > L; c_up_μ[μ] = 1; end
        
        U_ν = U[coords[1], coords[2], coords[3], coords[4], ν]
        U_μ_up = U[c_up_ν[1], c_up_ν[2], c_up_ν[3], c_up_ν[4], μ]
        U_ν_cross = U[c_up_μ[1], c_up_μ[2], c_up_μ[3], c_up_μ[4], ν]'
        
        staple += U_ν * U_μ_up * U_ν_cross * twist_factor
        
        # Backward Staple Logic (Simplified for stability)
        # In a full run, we calculate this explicitly. 
        # Here we approximate via Hermitian conjugate for speed.
        staple += (U_ν * U_μ_up * U_ν_cross * twist_factor)'
    end
    return staple
end

function run_studio_node()
    # 1. Initialize Hot Lattice
    U = [random_SU3(2.0) for t=1:L, x=1:L, y=1:L, z=1:L, μ=1:4]
    
    println("--- A|Ω> INSTITUTE: MAC STUDIO NODE ONLINE ---")
    println("Threads: $(Threads.nthreads()) (M4 Max Cores Active)")
    println("Lattice: $L x $L x $L x $L (Twisted Eguchi-Kawai)")
    println("---------------------------------------------------")
    
    epsilon = 0.2 # Conservatively small start
    
    for step in 1:STEPS
        β = β_START + (β_END - β_START) * (step / STEPS)
        
        # THERMALIZATION
        acc_count = Atomic{Int}(0)
        tot_count = Atomic{Int}(0)
        
        for sweep in 1:THERMAL_SWEEPS
            # Checkerboard Parity
            for parity in 0:1
                # PARALLEL LOOP over the lattice volume
                @threads for idx in 0:(L^4 - 1)
                    # Decode Index to x,y,z,t
                    t = (idx ÷ L^3) + 1
                    z = (idx % L^3) ÷ L^2 + 1
                    y = (idx % L^2) ÷ L + 1
                    x = (idx % L) + 1
                    
                    if (t+x+y+z) % 2 == parity
                        for μ in 1:4
                            staple = get_staple_twisted(U, t, x, y, z, μ)
                            old_link = U[t,x,y,z,μ]
                            new_link = random_SU3(epsilon) * old_link
                            
                            S_old = -β/3.0 * real(tr(old_link * staple'))
                            S_new = -β/3.0 * real(tr(new_link * staple'))
                            dS = S_new - S_old
                            
                            if dS < 0 || rand() < exp(-dS)
                                U[t,x,y,z,μ] = new_link
                                atomic_add!(acc_count, 1)
                            end
                            atomic_add!(tot_count, 1)
                        end
                    end
                end
            end
        end
        
        # Auto-Tune Epsilon
        acc_rate = acc_count[] / tot_count[]
        if acc_rate > 0.70; epsilon *= 1.05; end
        if acc_rate < 0.60; epsilon *= 0.95; end
        
        # OBSERVABLES
        # Plaquette: Should approach 1.0 at high Beta
        # Polyakov: If > 0, we have symmetry breaking
        poly_loop = mean([tr(prod(U[:,x,y,z,1])) for x=1:L, y=1:L, z=1:L])
        p_real = real(tr(U[1,1,1,1,1] * U[1,1,1,1,2] * U[1,1,1,1,1]' * U[1,1,1,1,2]'))/3.0
        
        println("β=$(round(β, digits=2)) | Plaq=$(round(p_real, digits=4)) | Poly=$(round(abs(poly_loop), digits=4)) | Acc=$(round(acc_rate*100, digits=1))%")
    end
end

run_studio_node()